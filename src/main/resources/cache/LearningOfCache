Cache学习：
    一、数据结构
        string：简单的key-value
        hash：存储结构化信息，比如用户信息（少了序列化和反序列化的操作）
        list:链表，比如消息队列，秒杀等
        set:无重复的列表，网站访问量
        Sorted set:有序无重复列表，排行榜
        HyperLogLog:可用作网站访问量，即使传入数据量非常大，计算技术所用的内存也非常小，12k内存就可计算2^64个不同元素的基数
        Geo:计算地理位置
        Pub/Sub:
    二、redis的事务
    三、删除策略
        （一）定时删除
            原理:创建一个定时器，定时器在过期时间来临时，立即删除
        （二）惰性删除
            原理：放任键的过期时间不管，但每次获取元素时都会检查是否过期。过期则删
            配置：服务器内置策略
        （三）定期删除
            原理：每隔一段时间，程序就对数据库进行一次检查，删除过期键
            配置：redis.conf  hz 刷新频率  maxmemory：当内存超过限定，主动触发清除策略
    四、持久化
        （一）RDB
            1.原理
                备份内存中的数据集
            2.命令
                SAVE：阻塞redis服务器进程，直到rdb文件创建完成
                BGSAVE：创建一个子线程，由子线程负责生成RDB文件，父线程继续处理请求
                        原理：fork创建子线程，cow 进行读写
            3.过期键处理
                生成：在创建RDB文件时，程序会对数据做过期校验，已过期的不会进行复制
                载入：/，则程序会对数据进行过期校验
                     服务器以从服务器身份运行，则程序会载入所有数据
                     但在主从同步时，从服务器的数据库就会被清空
        （二）AOF
            1.原理
                通过保存redis服务器所执行的写命令来记录数据库状态,AOF的功能分为追加，文件写入，文件同步
                    追加：当AOF持久化功能打开时，服务器在执行完一个命令后，会将命令追加到服务器aop_buff缓冲区去
                    文件写入与同步：当redis结束一个事件循环之后，会调用一个函数，将aof_buff缓冲区的命令写入文件
            2.相关配置
            AppendOnly：true/false 是否开启AOF功能
            Appendfilename:fileName 文件名称
            AppendSync：同步频率
            3.过期键处理
                载入：会对数据库进行过期检查
            4.复制
                从服务器只有接到主服务器发来的删除命令才会删除数据
    五、主从同步
        通过执行salveof或者在redis.conf设置slaveof配置项让一个服务器复制另一个服务器，被复制的服务器为主服务器（master）
        Redis的复制分为同步和命令传播
        PSYNC:具有完整重同步（PSYNC ? -1）和部分重同步两种模式（PSYNC [RunID] [offset]）
        （一）部分重同步的实现
            1.主服务器的复制偏移量和从服务器的复制偏移量
                主服务器每次向从服务器传播N个字节的数据，主服务器偏移量+N
                从服务器每次向主服务器接受N个字节的数据，从服务器偏移量+N
                偏移量相同则主从服务器处于一致状态
            2.主服务起的复制积压缓冲区
                复制积压缓冲区为一个FIFO的固定队列，默认1M
                当主服务器进行命令传播时，不仅把写命令发送给从服务器，而且会写入复制积压缓冲区，并为队列中每个字节记录复制偏移量
                复制积压缓冲区大小 ：second * write_size_per_second
            3.服务器的运行ID
                每个redis服务器都会有自己的运行ID
                当进行初次复制时，从服务器会保存主服务器的运行ID（RunID）
                若断线
                如果从服务器保存ID与主服务器一致，则进行部分重同步
                如果不一致，进行完全重同步
        （二）实现流程
            1.设置主服务器ip端口 ：slaveof [ip]:[port]
            2.建立套接字连接
            3.ping ：查看连接是否可用
            4.身份验证 （如果从服务器设置了masterauth）
            5.发送端口信息：从服务器发送，主服务器接受并记录到从服务器列表中
            6.同步
            7.命令传播
    六、redis分布锁
        先拿setnx争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记释放
        set指令有非常复杂的指令，是可以把setnx和expire合起来用的
    七、技巧
        使用keys指令可以扫出指定模式的key，但是由于redis是单线程的，会产生阻塞，   使用scan指令可以无阻塞的提取，但是可能会有重复
        Redis如何做异步队列：list实现，rpuch生产，lpop消费
        redis如何做延时队列：sorted set实现，拿时间戳作为权重，消息内容作为key调用zadd生产消息，消费者获取n秒前的数据
        生产一次消费多次：pub/sub，
    八、问题
        （一）穿透
            原理：频繁查询一个不存在的数据，由于缓存不命中，导致每次都要查询持久层
            解决：持久层查不到就缓存空结果，设置适当的过期时间
        （二）雪崩
            原理：缓存大量失效，引发大量的数据库查询
            解决：用锁/队列进行串行访问
                缓存过期时间均匀分布
        （三）热点key
            原理：某个key访问非常频繁，一旦过期，有大量线程来构建缓存
            解决：分布式锁
                不设置过期时间
        （四）主服务器DOWN
            redis集群会有一个监控中心，使用sentinel监控，每过down-after-millsseconds，
            执行心跳检查，若无反应，下线主服务器，

Redis和MenCached
    一、性能
        Redis只是用单核，MemCached使用多核
        存储小数据Redis,存储大量数据MemCached性能高
    二、内存空间和数据量
        MemCached可以修改最大内存
        Redis增加了VM的特性，突破了物理内存的限制
    三、数据
        MemCached数据结构单一，仅支持键值对
        Redis数据结构多样
    四、可靠性
        MemCached不支持数据持久化
        Redis支持数据持久化和数据恢复
